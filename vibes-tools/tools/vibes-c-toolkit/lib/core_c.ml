(* This module implements a [Theory.Core] interpretation for [FrontC]
   function bodies.

   Roughly speaking, a C function can be interpreted as a Core [unit
   Theory.eff], which is just a side effectful computation in the
   language of BAP's final tagless generic representation.

   The idea is quite straightforward:

   In any [Theory.Core] instance, there are a series of functions which
   construct various values of different built-in types. E.g. [set] takes
   a variable and a "pure" value, and returns an effect (morally the
   effect of setting that variable to that value).

   See the documentation of [Theory.Core] for (much) more detail.

   So we use this language to build the semantics of the various bits of
   C syntax. The main complications are as follows:

   - C has complex types and operations over those types. The [PatchC] 
     intermediate language has this information for us, and ensures that
     the program is explicitly and strictly typed. Later, we apply the
     remaining implicit conversion rules when lowering to [Core].

   - Since [Core] uses phantom types to be type-safe, we must re-sort all
     the arguments and cast them to "unit" (top) type using [resort].

   - [Core] does not have a construct for function calls (in particular,
     function calls with arguments!). Program labels in [Core] can be 
     annotated with a predicate that declares that they are at the start
     of a subroutine. Then, in the BAP IR theory, these control-flow
     constructs are correctly reified to function calls. For arguments
     we associate each particular call destination with a set of variables
     that were assigned leading up to the call. For this reason, each
     label for the destination must be unique.

   - The width of machine words, and the memory layout are stored in the
     [interp_info] type, which can be generated by reading the relevant values
     from the [Theory.target] which corresponds to the target architecture.

   - Jumps to concrete addresses are not possible directly in C. We support
     an alternate syntax: [goto L_some_hex_number], which in C syntax is an
     ordinary [goto] to a label, but which is handled specially by our
     processor.

   - Handling the ADDROF operator requires us to know the storage
     classification of an l-value in C, or to allocate on the stack.
     To keep things simple, we favor the former approach by asking the user
     to provide this information in the higher vars.
*)

open Core
open Bap.Std
open Bap_core_theory

module T = Theory
module Hvar = Vibes_higher_vars.Higher_var
module Substituter = Vibes_higher_vars.Substituter
module Naming = Substituter.Naming
module Function_info = Vibes_function_info.Types
module Utils = Vibes_utils

module Eval(CT : Theory.Core) = struct

  open KB.Syntax

  let fail (msg : string) : 'a KB.t = KB.fail @@ Errors.Core_c msg

  (* If `endian` evaluates to `b1` (true), then we are big-endian. *)
  type ('a, 'b) interp_info = {
    target    : T.target;
    word_sort : 'a T.Bitv.t T.Value.sort;
    byte_sort : 'b T.Bitv.t T.Value.sort;
    mem_var   : ('a, 'b) T.Mem.t T.var;
    endian    : T.Bool.t T.value;
    ret_var   : unit T.var;
    arg_vars  : unit T.var list;
    hvars     : Hvar.t list;
  } [@@deriving fields]

  let make_reg (target : T.target) (v : unit T.var) : unit T.var KB.t =
    let sort = T.Var.sort v in
    match Naming.mark_reg target @@ Var.reify v with
    | Error msg -> fail msg
    | Ok v -> !!(T.Var.create sort @@ Var.ident v)

  let make_ret_var (target : T.target) : unit T.var KB.t =
    let role = T.Role.Register.function_return in
    let ret_var = T.Target.reg target role in
    make_reg target @@ Option.value_exn ret_var

  let make_arg_vars (target : T.target) : unit T.var list KB.t =
    let roles = T.Role.Register.[function_argument] in
    let arg_vars = T.Target.regs target ~roles in
    Set.to_list arg_vars |> KB.List.map ~f:(make_reg target)

  let make_endian (target : T.target) : T.bool =
    let e = T.Target.endianness target in
    if T.Endianness.(e = eb) then CT.b1 else CT.b0

  let make_interp_info
      (hvars : Hvar.t list)
      (target : T.target) : ('a, 'b) interp_info KB.t =
    let word_sort = T.(Bitv.define @@ Target.bits target) in
    let byte_sort = T.(Bitv.define @@ Target.byte target) in
    let mem_var = T.Target.data target in
    let* endian = make_endian target in
    let* ret_var = make_ret_var target in
    let+ arg_vars = make_arg_vars target in
    Fields_of_interp_info.create
      ~target ~word_sort ~byte_sort ~mem_var
      ~endian ~ret_var ~arg_vars ~hvars

  let as_unsigned (t : Patch_c.typ) : Patch_c.typ = match t with
    | INT (size, _) -> INT (size, UNSIGNED)
    | _ -> t

  let ty_of_base_type
      (info : _ interp_info)
      (c_ty : Patch_c.typ) : _ T.Bitv.t T.Value.sort =
    T.Bitv.define @@ Patch_c.Type.size info.target c_ty

  let ty_op_pointer_type
      (info : _ interp_info)
      (c_ty : Patch_c.typ) : _ T.Bitv.t T.Value.sort KB.t =
    match c_ty with
    | PTR ty -> !!(ty_of_base_type info ty)
    | FUN _ -> !!(ty_of_base_type info c_ty)
    | _ -> fail "Core_c.ty_op_pointer_type: expected pointer type"

  let is_boolean_op (op : Patch_c.binop) : bool = match op with
    | ADD | SUB | MUL | DIV | MOD | LAND | LOR | XOR | SHL | SHR -> false
    | EQ | NE | LT | GT | LE | GE -> true

  (* Will this translate to a CT value of the bool sort? *)
  let is_boolean_exp (e : Patch_c.exp) : bool = match e with
    | BINARY (op, _, _, _) -> is_boolean_op op
    | _ -> false

  let resort (sort : 'a T.Value.sort) (v : 'b T.value) : 'a T.value KB.t =
    T.Value.resort (fun _ -> Some sort) v |> function
    | None -> fail "Incorrect argument sort"
    | Some v -> !!v

  type 'a pure = 'a T.pure

  let lift_binop
      (op : 'a T.value KB.t -> 'b T.value KB.t -> 'c T.value KB.t)
      (sort_a : 'a T.Value.sort)
      (sort_b : 'b T.Value.sort)
      (a : unit pure)
      (b : unit pure) : unit pure =
    let* a = a in
    let* b = b in
    let+ res = op (resort sort_a a) (resort sort_b b) in
    T.Value.forget res

  let binop_to_pure
      (info : _ interp_info)
      (op : Patch_c.binop)
      (ty_a : Patch_c.typ)
      (ty_b : Patch_c.typ) : (unit pure -> unit pure -> unit pure) KB.t =
    let lift_bitv op =
      lift_binop op
        (ty_of_base_type info ty_a)
        (ty_of_base_type info ty_b) in
    match op with
    | ADD -> !!(lift_bitv CT.add)
    | SUB -> !!(lift_bitv CT.sub)
    | MUL -> !!(lift_bitv CT.mul)
    | DIV -> begin
        match Patch_c.Type.sign ty_a, Patch_c.Type.sign ty_b with
        | None, _ | _, None ->
          fail "DIV requires a signedness on both operands"
        | Some UNSIGNED, _ | _, Some UNSIGNED -> !!(lift_bitv CT.div)
        | Some SIGNED, Some SIGNED -> !!(lift_bitv CT.sdiv)
      end
    | MOD -> begin
        match Patch_c.Type.sign ty_a, Patch_c.Type.sign ty_b with
        | None, _ | _, None ->
          fail "MOD requires a signedness on both operands"
        | Some UNSIGNED, _ | _, Some UNSIGNED -> !!(lift_bitv CT.modulo)
        | Some SIGNED, Some SIGNED -> !!(lift_bitv CT.smodulo)
      end
    | LAND -> !!(lift_bitv CT.logand)
    | LOR -> !!(lift_bitv CT.logor)
    | XOR -> !!(lift_bitv CT.logxor)
    | SHL -> !!(lift_bitv CT.lshift)
    | SHR  -> begin
        match Patch_c.Type.sign ty_a, Patch_c.Type.sign ty_b with
        | Some SIGNED, Some _ -> !!(lift_bitv CT.arshift)
        | Some UNSIGNED, Some _ -> !!(lift_bitv CT.rshift)
        | None, _ | _, None ->
          fail "SHR requires a signedness on both operands"
      end
    | EQ  -> !!(lift_bitv CT.eq)
    | NE  -> !!(lift_bitv CT.neq)
    | LT -> begin
        match Patch_c.Type.sign ty_a, Patch_c.Type.sign ty_b with
        | None, None -> !!(lift_bitv CT.ult)
        | None, _ | _, None ->
          fail "LT requires a signedness on both operands or on none"
        | Some UNSIGNED, _ | _, Some UNSIGNED -> !!(lift_bitv CT.ult)
        | Some SIGNED, Some SIGNED -> !!(lift_bitv CT.slt)
      end
    | GT -> begin
        match Patch_c.Type.sign ty_a, Patch_c.Type.sign ty_b with
        | None, None -> !!(lift_bitv CT.ugt)
        | None, _ | _, None ->
          fail "GT requires a signedness on both operands or on none"
        | Some UNSIGNED, _ | _, Some UNSIGNED -> !!(lift_bitv CT.ugt)
        | Some SIGNED, Some SIGNED -> !!(lift_bitv CT.sgt)
      end
    | LE -> begin
        match Patch_c.Type.sign ty_a, Patch_c.Type.sign ty_b with
        | None, None -> !!(lift_bitv CT.ule)
        | None, _ | _, None ->
          fail "LE requires a signedness on both operands or on none"
        | Some UNSIGNED, _ | _, Some UNSIGNED -> !!(lift_bitv CT.ule)
        | Some SIGNED, Some SIGNED -> !!(lift_bitv CT.sle)
      end
    | GE -> begin
        match Patch_c.Type.sign ty_a, Patch_c.Type.sign ty_b with
        | None, None -> !!(lift_bitv CT.uge)
        | None, _ | _, None ->
          fail "GE requires a signedness on both operands or on none"
        | Some UNSIGNED, _ | _, Some UNSIGNED -> !!(lift_bitv CT.uge)
        | Some SIGNED, Some SIGNED -> !!(lift_bitv CT.sge)
      end

  type 'a bitv = 'a T.bitv

  let lift_uop
      (op : 'a T.value KB.t -> 'b T.value KB.t)
      (sort_a : 'a T.Value.sort)
      (a : unit pure) : unit pure =
    let* a = a in
    let+ res = op (resort sort_a a) in
    T.Value.forget res

  let unop_to_pure
      (info : _ interp_info)
      (op : Patch_c.unop)
      (ty : Patch_c.typ) : (unit pure -> unit pure) KB.t =
    let lift_bitv op = lift_uop op info.word_sort in
    match op with
    | MINUS -> !!(lift_bitv CT.neg)
    | LNOT -> !!(lift_bitv CT.not)
    | MEMOF ->
      let+ ty = ty_op_pointer_type info ty in
      let load : _ bitv -> _ bitv =
        CT.(loadw ty !!(info.endian) (var info.mem_var)) in
      lift_bitv load
    | ADDROF -> fail "unop_to_pure: ADDROF unsupported by VIBES"

  let try_mark_reg
      (info : ('a, _) interp_info)
      (reg : string) : 'a T.Bitv.t T.var KB.t =
    match Naming.mark_reg_name info.target reg with
    | Ok s -> !!T.Var.(create info.word_sort @@ Ident.of_string s)
    | Error msg -> fail msg

  let addr_of_var (info : _ interp_info) (v : string) : unit pure =
    match Hvar.find v info.hvars with
    | None ->
      fail @@ sprintf "laddr_of_var: missing higher var %s for ADDROF \
                       expression, storage classification is required" v
    | Some {value; _} -> match value with
      | Hvar.(Memory (Frame (reg, off))) ->
        let* reg = try_mark_reg info reg in
        let+ a =
          CT.add (CT.var reg)
            (CT.int info.word_sort (Word.to_bitvec off)) in
        T.Value.forget a
      | Hvar.(Memory (Global addr))->
        let+ a = CT.int info.word_sort (Word.to_bitvec addr) in
        T.Value.forget a
      | _ ->
        fail @@ sprintf "addr_of_var: higher var %s for ADDROF expression \
                         is not stored in a memory location." v

  let rec expr_to_pure
      (info : _ interp_info)
      (e : Patch_c.exp) : unit pure =
    let aux = expr_to_pure info in
    let aux_bool t e =
      (* The semantics of C with boolean values is not compatible with
         the strict typing discipline of Core Theory, so we need to insert
         explicit casts where necessary. *)
      if is_boolean_exp e then
        let t = as_unsigned t in
        aux @@ CAST (t, Patch_c.Exp.coerce_type e t)
      else aux e in
    match e with
    | UNARY (ADDROF, VARIABLE (v, _), _) -> addr_of_var info @@ T.Var.name v
    | UNARY (ADDROF, UNARY (MEMOF, a, _), _) -> aux a
    | UNARY (op, a, _) ->
      let ty_a = Patch_c.Exp.typeof a in
      let* a = aux_bool ty_a a in
      let* o = unop_to_pure info op ty_a in
      o !!a
    | BINARY (op, a, b, _) ->
      let ty_a = Patch_c.Exp.typeof a in
      let ty_b = Patch_c.Exp.typeof b in
      let* a, b =
        if not @@ is_boolean_op op then
          let* a = aux_bool ty_a a and* b = aux_bool ty_b b in
          !!(a, b)
        else
          let* a = aux a and* b = aux b in
          !!(a, b) in
      let* o = binop_to_pure info op ty_a ty_b in
      o !!a !!b
    | VARIABLE (v, _) -> CT.var v
    | CONST_INT (w, _) ->
      let+ i = CT.int info.word_sort @@ Word.to_bitvec w in
      T.Value.forget i
    | CAST (t, e) ->
      let t' = Patch_c.Exp.typeof e in
      let sz = Patch_c.Type.size info.target t in
      let sz' = Patch_c.Type.size info.target t' in
      let* e' = aux e in
      if sz = sz' && not @@ is_boolean_exp e then !!e'
      else
        let s = ty_of_base_type info t in
        let s' = ty_of_base_type info t' in
        let e = resort s' e' in
        let+ c =
          (* No extension, just grab the lower bits. *)
          if sz < sz' then CT.low s e
          else
            (* Apply the integral promotion rules. Based on the signedness of
               each type, figure out if we need a sign extension or a zero
               extension. *)
            match Patch_c.Type.sign t, Patch_c.Type.sign t' with
            | Some SIGNED,   Some SIGNED   -> CT.signed   s e
            | Some SIGNED,   Some UNSIGNED -> CT.unsigned s e
            | Some UNSIGNED, Some SIGNED   -> CT.signed   s e
            | Some UNSIGNED, Some UNSIGNED -> CT.unsigned s e
            (* Assume unsigned. *)
            | None, _ | _, None -> CT.unsigned s e in
        T.Value.forget c

  type 'a eff = 'a T.eff

  let empty_data : T.data T.effect = T.Effect.(empty @@ Sort.data "C_NOP")

  let assign_args
      (info : _ interp_info)
      (args : Patch_c.exp list) : (T.data eff * var list) KB.t =
    try
      let* args = KB.List.map args ~f:(expr_to_pure info) in
      List.mapi args ~f:(fun i a ->
          let r = List.nth_exn info.arg_vars i in
          CT.set r !!a, Var.reify r) |>
      KB.List.fold_right ~init:(!!empty_data, [])
        ~f:(fun (assn, r) (acc_eff, acc_args) ->
            !!(CT.seq assn acc_eff, r :: acc_args))
    with _ ->
      fail "Maximum number of arguments for function call was exceeded"

  let call_dst_with_name (name : string) : T.label KB.t =
    let* dst = T.Label.fresh in
    let* () = KB.provide T.Label.name dst @@ Some name in
    let+ () = KB.provide T.Label.is_subroutine dst @@ Some true in
    dst

  let call_dst_with_addr (addr : Bitvec.t) : T.label KB.t =
    let* dst = T.Label.fresh in
    let* () = KB.provide T.Label.addr dst @@ Some addr in
    let+ () = KB.provide T.Label.is_subroutine dst @@ Some true in
    dst

  let determine_call_dst (f : Patch_c.exp) : T.label KB.t = match f with
    | VARIABLE (v, _) -> call_dst_with_name @@ T.Var.name v
    | CAST (_, CONST_INT (w, _)) -> call_dst_with_addr @@ Word.to_bitvec w
    | _ ->
      (* We currently don't support indirect calls for two reasons:

         1. It's not implemented in the backend yet.
         2. We currently associate the arguments of the call with
            a label, but we can't use a label for an indirect call.
      *)
      fail @@ sprintf "Unsupported indirect call: %s\n%!" @@
      Patch_c.Exp.to_string f

  let empty_ctrl = T.Effect.(empty Sort.fall)
  let empty_blk = CT.blk T.Label.null !!empty_data !!empty_ctrl
  let data d = CT.blk T.Label.null d !!empty_ctrl
  let ctrl c = CT.blk T.Label.null !!empty_data c
  let block d c = CT.blk T.Label.null d c

  let new_func
      (func_infos : Function_info.t)
      (args : var list)
      (dst : T.label) : Function_info.t KB.t =
    let* name = KB.collect Theory.Label.name dst in
    let+ addr = KB.collect Theory.Label.addr dst in
    let arg_names = List.map args ~f:Var.name in
    let func_info = Function_info.create_func dst arg_names ?name ?addr in
    Function_info.append func_infos ~func_info

  let rec stmt_to_eff
      ~(info : _ interp_info)
      ~(func_infos : Function_info.t)
      (s : Patch_c.stmt) : (unit eff * Function_info.t) KB.t = match s with
    | NOP -> !!(empty_blk, func_infos)
    | BLOCK (_, s) -> stmt_to_eff s ~info ~func_infos
    | ASSIGN ((v, t), e) ->
      let s = ty_of_base_type info t in
      let v = T.Var.resort v s in
      let+ e = expr_to_pure info e in
      data CT.(set v @@ resort s e), func_infos
    | CALL (f, args) ->
      let* dst = determine_call_dst f in
      let* setargs, args = assign_args info args in
      let+ func_infos = new_func func_infos args dst in
      CT.(block setargs (goto dst)), func_infos
    | CALLASSIGN ((v, _), f, args) ->
      let* dst = determine_call_dst f in
      let* setargs, args = assign_args info args in
      let+ func_infos = new_func func_infos args dst in
      let term =
        CT.(seq (block setargs (goto dst))
              (data @@ set v @@ var info.ret_var)) in
      term, func_infos
    | STORE (l, r) ->
      let sr = ty_of_base_type info @@ Patch_c.Exp.typeof r in
      let* l = expr_to_pure info l in
      let+ r = expr_to_pure info r in
      let term =
        CT.(data
              (set info.mem_var
                 (storew !!(info.endian)
                    (var info.mem_var)
                    (resort info.word_sort l)
                    (resort sr r)))) in
      term, func_infos
    | SEQUENCE (s1, s2) ->
      let* s1, func_infos = stmt_to_eff s1 ~info ~func_infos in
      let+ s2, func_infos = stmt_to_eff s2 ~info ~func_infos in
      CT.seq s1 s2, func_infos
    | IF (cond, st, sf) ->
      let* c = expr_to_pure info cond in
      let c =
        (* The semantics of C is that a truth value can be of any bitwidth,
           and the comparison should check if it is nonzero. Still, we would
           like to translate to the stricter Core Theory semantics such that
           the truth values are well-sorted. *)
        if not @@ is_boolean_exp cond then
          let tcond = Patch_c.Exp.typeof cond in
          let scond = ty_of_base_type info tcond in
          let zero = Word.(
              to_bitvec @@ zero @@
              Patch_c.Type.size info.target tcond) in
          let zero = CT.int scond zero in
          CT.neq (resort scond c) zero
        else resort T.Bool.t c in
      let* st, func_infos = stmt_to_eff st ~info ~func_infos in
      let+ sf, func_infos = stmt_to_eff sf ~info ~func_infos in
      CT.branch c st sf, func_infos
    | GOTO label when String.(is_prefix ~prefix:"L_0x" label) ->
      let label = String.(chop_prefix_exn ~prefix:"L_" label) in
      !!(ctrl CT.(jmp (int info.word_sort Bitvec.(!$ label))), func_infos)
    | GOTO label ->
      let+ label = T.Label.for_name label in
      ctrl CT.(goto label), func_infos

  and body_to_eff info (prog : Patch_c.t)
    : (unit eff * Function_info.t) KB.t =
    let _, stmt = prog.body in
    stmt_to_eff stmt ~info ~func_infos:Function_info.empty

  let parse
      (hvars : Hvar.t list)
      (target : T.target)
      (patch : Cabs.definition) : (unit eff * Function_info.t) KB.t =
    let* body = Patch_c.translate patch ~target in
    let* info = make_interp_info hvars target in
    body_to_eff info body

end
