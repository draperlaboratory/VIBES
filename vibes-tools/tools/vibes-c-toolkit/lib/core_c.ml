(* This module implements a [Theory.Core] interpretation for [FrontC]
   function bodies.

   Roughly speaking, a C function can be interpreted as a Core [unit
   Theory.eff], which is just a side effectful computation in the
   language of BAP's final tagless generic representation.

   The idea is quite straightforward:

   In any [Theory.Core] instance, there are a series of functions which
   construct various values of different built-in types. E.g. [set] takes
   a variable and a "pure" value, and returns an effect (morally the
   effect of setting that variable to that value).

   See the documentation of [Theory.Core] for (much) more detail.

   So we use this language to build the semantics of the various bits of
   C syntax. The main complications are as follows:

   - C has complex types and operations over those types. The [PatchC] 
     intermediate language has this information for us, and ensures that
     the program is explicitly and strictly typed. Later, we apply the
     remaining implicit conversion rules when lowering to [Core].

   - Since [Core] uses phantom types to be type-safe, we must re-sort all
     the arguments and cast them to "unit" (top) type using [resort].

   - [Core] does not have a construct for function calls (in particular,
     function calls with arguments!). Program labels in [Core] can be 
     annotated with a predicate that declares that they are at the start
     of a subroutine. Then, in the BAP IR theory, these control-flow
     constructs are correctly reified to function calls. For arguments
     we associate each particular call destination with a set of variables
     that were assigned leading up to the call. For this reason, each
     label for the destination must be unique.

   - The width of machine words, and the memory layout are stored in the
     [interp_info] type, which can be generated by reading the relevant values
     from the [Theory.target] which corresponds to the target architecture.

   - Jumps to concrete addresses are not possible directly in C. We support
     an alternate syntax: [goto L_some_hex_number], which in C syntax is an
     ordinary [goto] to a label, but which is handled specially by our
     processor.

   - Handling the ADDROF operator requires us to know the storage
     classification of an l-value in C, or to allocate on the stack.
     To keep things simple, we favor the former approach by asking the user
     to provide this information in the higher vars.
*)

open Core
open Bap.Std
open Bap_c.Std
open Bap_core_theory

module T = Theory
module Hvar = Vibes_higher_vars.Higher_var
module Substituter = Vibes_higher_vars.Substituter
module Naming = Substituter.Naming
module Utils = Vibes_utils
module Data_model = Patch_c.Data_model

let package = Vibes_constants.Bap_kb.package

let call_with_args : (Theory.program, Var.Set.t) KB.slot =
  KB.Class.property T.Program.cls "call-with-args" ~package @@
  KB.Domain.powerset (module Var.Set.Elt) "var-set-domain"

module Make(CT : Theory.Core) = struct

  open KB.Syntax

  let fail (msg : string) : 'a KB.t = KB.fail @@ Errors.Core_c msg

  (* If `endian` evaluates to `b1` (true), then we are big-endian. *)
  type ('a, 'b) interp_info = {
    target      : T.target;
    word_sort   : 'a T.Bitv.t T.Value.sort;
    byte_sort   : 'b T.Bitv.t T.Value.sort;
    mem_var     : ('a, 'b) T.Mem.t T.var;
    endian      : T.Bool.t T.value;
    ret_var     : unit T.var;
    arg_vars    : unit T.var list;
    hvars       : Hvar.t list;
    data        : Data_model.t;
    csize       : C.Size.base;
    as_unsigned : C.Type.t -> C.Type.t;
    label_env   : String.Set.t;
  } [@@deriving fields]

  let make_reg (target : T.target) (v : unit T.var) : unit T.var KB.t =
    let sort = T.Var.sort v in
    match Naming.mark_reg target @@ Var.reify v with
    | Error msg -> fail msg
    | Ok v -> !!(T.Var.create sort @@ Var.ident v)

  let make_ret_var (target : T.target) : unit T.var KB.t =
    let role = T.Role.Register.function_return in
    let ret_var = T.Target.reg target role in
    make_reg target @@ Option.value_exn ret_var

  let make_arg_vars (target : T.target) : unit T.var list KB.t =
    let roles = T.Role.Register.[function_argument] in
    let arg_vars = T.Target.regs target ~roles in
    Set.to_list arg_vars |> KB.List.map ~f:(make_reg target)

  let make_endian (target : T.target) : T.bool =
    let e = T.Target.endianness target in
    if T.Endianness.(e = eb) then CT.b1 else CT.b0

  let as_unsigned (data : Data_model.t) : C.Type.t -> C.Type.t =
    let obj = object
      inherit [C.Type.t] C.Type.Mapper.base
      method! map_integer = function
        | `char       -> if Data_model.schar data then `uchar else `char
        | `schar      -> `uchar
        | `sshort     -> `ushort
        | `sint       -> `uint
        | `slong      -> `ulong
        | `slong_long -> `ulong_long
        | i           -> i
    end in obj#run

  let make_interp_info
      (hvars : Hvar.t list)
      (target : T.target)
      (data : Data_model.t)
      (csize : C.Size.base)
      (label_env : String.Set.t) : ('a, 'b) interp_info KB.t =
    let word_sort = T.(Bitv.define @@ Target.bits target) in
    let byte_sort = T.(Bitv.define @@ Target.byte target) in
    let mem_var = T.Target.data target in
    let* endian = make_endian target in
    let* ret_var = make_ret_var target in
    let+ arg_vars = make_arg_vars target in
    let as_unsigned = as_unsigned data in
    Fields_of_interp_info.create
      ~target ~word_sort ~byte_sort ~mem_var
      ~endian ~ret_var ~arg_vars ~hvars
      ~data ~csize ~as_unsigned ~label_env

  let ty_of_base_type
      (info : _ interp_info)
      (c_ty : Patch_c.typ) : _ T.Bitv.t T.Value.sort =
    T.Bitv.define @@ Option.value_exn (info.csize#bits c_ty)

  let ty_op_pointer_type
      (info : _ interp_info)
      (c_ty : Patch_c.typ) : _ T.Bitv.t T.Value.sort KB.t =
    match c_ty with
    | `Pointer {C.Type.Spec.t = ty; _} -> !!(ty_of_base_type info ty)
    | `Function _ -> !!(ty_of_base_type info c_ty)
    | _ -> fail "Core_c.ty_op_pointer_type: expected pointer type"

  let is_boolean_op (op : Patch_c.binop) : bool = match op with
    | ADD | SUB | MUL | DIV | MOD | LAND | LOR | XOR | SHL | SHR -> false
    | EQ | NE | LT | GT | LE | GE -> true

  (* Will this translate to a CT value of the bool sort? *)
  let is_boolean_exp (e : Patch_c.exp) : bool = match e with
    | BINARY (op, _, _, _) -> is_boolean_op op
    | _ -> false

  let resort (sort : 'a T.Value.sort) (v : 'b T.value) : 'a T.value KB.t =
    T.Value.resort (fun _ -> Some sort) v |> function
    | None -> fail "Incorrect argument sort"
    | Some v -> !!v

  type 'a pure = 'a T.pure

  let lift_binop
      (op : 'a T.value KB.t -> 'b T.value KB.t -> 'c T.value KB.t)
      (sort_a : 'a T.Value.sort)
      (sort_b : 'b T.Value.sort)
      (a : unit pure)
      (b : unit pure) : unit pure =
    let* a = a in
    let* b = b in
    let+ res = op (resort sort_a a) (resort sort_b b) in
    T.Value.forget res

  let binop_to_pure
      (info : _ interp_info)
      (op : Patch_c.binop)
      (ty_a : Patch_c.typ)
      (ty_b : Patch_c.typ) : (unit pure -> unit pure -> unit pure) KB.t =
    let lift_bitv op =
      lift_binop op
        (ty_of_base_type info ty_a)
        (ty_of_base_type info ty_b) in
    match op with
    | ADD -> !!(lift_bitv CT.add)
    | SUB -> !!(lift_bitv CT.sub)
    | MUL -> !!(lift_bitv CT.mul)
    | DIV -> begin
        match Patch_c.Type.sign info.data ty_a,
              Patch_c.Type.sign info.data ty_b with
        | UNSIGNED, _ | _, UNSIGNED -> !!(lift_bitv CT.div)
        | SIGNED, SIGNED -> !!(lift_bitv CT.sdiv)
      end
    | MOD -> begin
        match Patch_c.Type.sign info.data ty_a,
              Patch_c.Type.sign info.data ty_b with
        | UNSIGNED, _ | _, UNSIGNED -> !!(lift_bitv CT.modulo)
        | SIGNED, SIGNED -> !!(lift_bitv CT.smodulo)
      end
    | LAND -> !!(lift_bitv CT.logand)
    | LOR -> !!(lift_bitv CT.logor)
    | XOR -> !!(lift_bitv CT.logxor)
    | SHL -> !!(lift_bitv CT.lshift)
    | SHR  -> begin
        match Patch_c.Type.sign info.data ty_a,
              Patch_c.Type.sign info.data ty_b with
        | SIGNED, _ -> !!(lift_bitv CT.arshift)
        | UNSIGNED, _ -> !!(lift_bitv CT.rshift)
      end
    | EQ  -> !!(lift_bitv CT.eq)
    | NE  -> !!(lift_bitv CT.neq)
    | LT -> begin
        match Patch_c.Type.sign info.data ty_a,
              Patch_c.Type.sign info.data ty_b with
        | UNSIGNED, _ | _, UNSIGNED -> !!(lift_bitv CT.ult)
        | SIGNED, SIGNED -> !!(lift_bitv CT.slt)
      end
    | GT -> begin
        match Patch_c.Type.sign info.data ty_a,
              Patch_c.Type.sign info.data ty_b with
        | UNSIGNED, _ | _, UNSIGNED -> !!(lift_bitv CT.ugt)
        | SIGNED, SIGNED -> !!(lift_bitv CT.sgt)
      end
    | LE -> begin
        match Patch_c.Type.sign info.data ty_a,
              Patch_c.Type.sign info.data ty_b with
        | UNSIGNED, _ | _, UNSIGNED -> !!(lift_bitv CT.ule)
        | SIGNED, SIGNED -> !!(lift_bitv CT.sle)
      end
    | GE -> begin
        match Patch_c.Type.sign info.data ty_a,
              Patch_c.Type.sign info.data ty_b with
        | UNSIGNED, _ | _, UNSIGNED -> !!(lift_bitv CT.uge)
        | SIGNED, SIGNED -> !!(lift_bitv CT.sge)
      end

  type 'a bitv = 'a T.bitv

  let lift_uop
      (op : 'a T.value KB.t -> 'b T.value KB.t)
      (sort_a : 'a T.Value.sort)
      (a : unit pure) : unit pure =
    let* a = a in
    let+ res = op (resort sort_a a) in
    T.Value.forget res

  let unop_to_pure
      (info : _ interp_info)
      (op : Patch_c.unop)
      (ty : Patch_c.typ) : (unit pure -> unit pure) KB.t =
    let lift_bitv op = lift_uop op info.word_sort in
    match op with
    | MINUS -> !!(lift_bitv CT.neg)
    | LNOT -> !!(lift_bitv CT.not)
    | MEMOF ->
      let+ ty = ty_op_pointer_type info ty in
      let load : _ bitv -> _ bitv =
        CT.(loadw ty !!(info.endian) (var info.mem_var)) in
      lift_bitv load
    | ADDROF -> fail "unop_to_pure: ADDROF unsupported by VIBES"

  let try_mark_reg
      (info : ('a, _) interp_info)
      (reg : string) : 'a T.Bitv.t T.var KB.t =
    match Naming.mark_reg_name info.target reg with
    | Ok s -> !!T.Var.(create info.word_sort @@ Ident.of_string s)
    | Error msg -> fail msg

  let addr_of_var (info : _ interp_info) (v : string) : unit pure =
    match Hvar.find v info.hvars with
    | None ->
      let msg = Format.sprintf
          "addr_of_var: missing higher var %s for ADDROF \
           expression, storage classification is required" v in
      fail msg
    | Some {value; _} -> match value with
      | Hvar.(Memory (Frame (reg, off))) ->
        let* reg = try_mark_reg info reg in
        let+ a =
          CT.add (CT.var reg)
            (CT.int info.word_sort (Word.to_bitvec off)) in
        T.Value.forget a
      | Hvar.(Memory (Global addr))->
        let+ a = CT.int info.word_sort (Word.to_bitvec addr) in
        T.Value.forget a
      | _ ->
        let msg = Format.sprintf
            "addr_of_var: higher var %s for ADDROF expression \
             is not stored in a memory location." v in
        fail msg

  let rec expr_to_pure
      (info : _ interp_info)
      (e : Patch_c.exp) : unit pure =
    let aux = expr_to_pure info in
    let aux_bool t e =
      (* The semantics of C with boolean values is not compatible with
         the strict typing discipline of Core Theory, so we need to insert
         explicit casts where necessary. *)
      if is_boolean_exp e then
        let t = info.as_unsigned t in
        aux @@ CAST (t, Patch_c.Exp.coerce_type info.data info.csize e t)
      else aux e in
    match e with
    | UNARY (ADDROF, VARIABLE (v, _), _) -> addr_of_var info @@ T.Var.name v
    | UNARY (ADDROF, UNARY (MEMOF, a, _), _) -> aux a
    | UNARY (op, a, _) ->
      let ty_a = Patch_c.Exp.typeof info.data a in
      let* a = aux_bool ty_a a in
      let* o = unop_to_pure info op ty_a in
      o !!a
    | BINARY (op, a, b, _) ->
      let ty_a = Patch_c.Exp.typeof info.data a in
      let ty_b = Patch_c.Exp.typeof info.data b in
      let* a, b =
        if not @@ is_boolean_op op then
          let* a = aux_bool ty_a a and* b = aux_bool ty_b b in
          !!(a, b)
        else
          let* a = aux a and* b = aux b in
          !!(a, b) in
      let* o = binop_to_pure info op ty_a ty_b in
      o !!a !!b
    | VARIABLE (v, _) -> CT.var v
    | CONST_INT (w, _) ->
      let+ i = CT.int info.word_sort @@ Word.to_bitvec w in
      T.Value.forget i
    | CAST (t, e) ->
      let t' = Patch_c.Exp.typeof info.data e in
      let sz = Option.value_exn (info.csize#bits t) in
      let sz' = Option.value_exn (info.csize#bits t') in
      let* e' = aux e in
      if sz = sz' && not @@ is_boolean_exp e then !!e'
      else
        let s = ty_of_base_type info t in
        let s' = ty_of_base_type info t' in
        let e = resort s' e' in
        let+ c =
          (* No extension, just grab the lower bits. *)
          if sz < sz' then CT.low s e
          else
            (* Apply the integral promotion rules. Based on the signedness of
               each type, figure out if we need a sign extension or a zero
               extension. *)
            match Patch_c.Type.sign info.data t,
                  Patch_c.Type.sign info.data t' with
            | SIGNED,   SIGNED   -> CT.signed   s e
            | SIGNED,   UNSIGNED -> CT.unsigned s e
            | UNSIGNED, SIGNED   -> CT.signed   s e
            | UNSIGNED, UNSIGNED -> CT.unsigned s e in
        T.Value.forget c

  type 'a eff = 'a T.eff

  let empty_data : T.data T.effect = T.Effect.(empty @@ Sort.data "C_NOP")

  let assign_args
      (call : Patch_c.stmt)
      (info : _ interp_info)
      (args : Patch_c.exp list) : (T.data eff * var list) KB.t =
    try
      let* args = KB.List.map args ~f:(fun arg ->
          match Patch_c.Exp.typeof info.data arg with
          | `Structure _ ->
            let msg = Format.sprintf
                "Unsupported: cannot pass struct %s as a \
                 function argument" @@ Patch_c.Exp.to_string arg in
            fail msg
          | _ -> expr_to_pure info arg) in
      List.mapi args ~f:(fun i a ->
          let r = List.nth_exn info.arg_vars i in
          CT.set r !!a, Var.reify r) |>
      KB.List.fold_right ~init:(!!empty_data, [])
        ~f:(fun (assn, r) (acc_eff, acc_args) ->
            !!(CT.seq assn acc_eff, r :: acc_args))
    with _ ->
      (* Currently, we only support passing arguments by registers, which
         are in limited number. *)
      let call = Patch_c.Stmt.to_string call in
      let len = List.length info.arg_vars in
      let msg = Format.sprintf
          "At function call:\n\n%s:\n\nmaximum number of \
           arguments (%d) was exceeded" call len in
      fail msg

  let call_dst_with_name (name : string) : T.label KB.t =
    let* dst = T.Label.fresh in
    let* () = KB.provide T.Label.name dst @@ Some name in
    let+ () = KB.provide T.Label.is_subroutine dst @@ Some true in
    dst

  let call_dst_with_addr (addr : Bitvec.t) : T.label KB.t =
    let* dst = T.Label.fresh in
    let* () = KB.provide T.Label.addr dst @@ Some addr in
    let+ () = KB.provide T.Label.is_subroutine dst @@ Some true in
    dst

  let determine_call_dst (f : Patch_c.exp) : T.label KB.t = match f with
    | VARIABLE (v, _) -> call_dst_with_name @@ T.Var.name v
    | CAST (_, CONST_INT (w, _)) -> call_dst_with_addr @@ Word.to_bitvec w
    | _ ->
      fail @@ sprintf "Unsupported indirect call: %s\n%!" @@
      Patch_c.Exp.to_string f

  let empty_ctrl = T.Effect.(empty Sort.fall)
  let empty_blk ?(l = T.Label.null) () = CT.blk l !!empty_data !!empty_ctrl
  let data d = CT.blk T.Label.null d !!empty_ctrl
  let ctrl c = CT.blk T.Label.null !!empty_data c
  let block ?(l = T.Label.null) d c = CT.blk l d c

  (* Currently, we only support bitv-like return types in our C frontend.
     If we call a function that returns a value that's smaller than the
     size of the return register, then we need to add a cast to to keep
     the Core Theory program well-typed. *)
  let cast_call_assign
      (v : unit T.var)
      ~(info : _ interp_info) : T.data eff =
    match T.Bitv.refine @@ T.Var.sort v with
    |  None ->
      let msg = Format.asprintf
          "Expected bitv sort for CALLASSIGN of var %a"
          T.Var.pp v in
      fail msg
    | Some s ->
      let ret =
        if T.Value.Sort.same s info.word_sort then
          let* v = CT.var info.ret_var in
          let+ c = CT.(cast s b0 (resort info.word_sort v)) in
          T.Value.forget c
        else CT.var info.ret_var in
      CT.set v ret

  (* If we're passing arguments to the call, then we should do it in
     a uniquely identifiable block so that we can do some bookkeeping
     of the argument variables later. *)
  let args_label : var list -> T.label option KB.t = function
    | [] -> !!None
    | args ->
      let* l = T.Label.fresh in
      let+ () = KB.provide call_with_args l @@ Var.Set.of_list args in
      Some l

  (* This is a hack to prevent an optimization performed by the BIL IR
     theory, where our "call" block is merged into some predecessor and
     we lose the provenance of the arguments information. *)
  let goto_call ?l c = match l with
    | Some l -> CT.(seq (ctrl (goto l)) c)
    | None -> c

  let rec stmt_to_eff
      (s : Patch_c.stmt)
      ~(info : _ interp_info) : unit eff KB.t = match s with
    | NOP -> !!(empty_blk ())
    | BLOCK {stmt; label = None; _} -> stmt_to_eff stmt ~info
    | BLOCK {stmt; label = Some l; _} ->
      let* l = T.Label.for_name l in
      let* b = empty_blk ~l () in
      let+ s = stmt_to_eff stmt ~info in
      CT.seq !!b s
    | ASSIGN ((v, t), e) ->
      let s = ty_of_base_type info t in
      let v = T.Var.resort v s in
      let+ e = expr_to_pure info e in
      data CT.(set v @@ resort s e)
    | CALL (f, args) ->
      let* dst = determine_call_dst f in
      let* setargs, args = assign_args s info args in
      let+ l = args_label args in
      goto_call ?l CT.(block setargs (goto dst) ?l)
    | CALLASSIGN ((v, _), f, args) ->
      let* dst = determine_call_dst f in
      let* setargs, args = assign_args s info args in
      let+ l = args_label args in
      goto_call ?l
        CT.(seq (block setargs (goto dst) ?l)
              (data @@ cast_call_assign v ~info))
    | STORE (l, r) ->
      let sr =
        ty_of_base_type info @@
        Patch_c.Exp.typeof info.data r in
      let* l = expr_to_pure info l in
      let+ r = expr_to_pure info r in
      CT.(data
            (set info.mem_var
               (storew !!(info.endian)
                  (var info.mem_var)
                  (resort info.word_sort l)
                  (resort sr r))))
    | SEQUENCE (s1, s2) ->
      let* s1 = stmt_to_eff s1 ~info in
      let+ s2 = stmt_to_eff s2 ~info in
      CT.seq s1 s2
    | IF (cond, st, sf) ->
      let* c = expr_to_pure info cond in
      let c =
        (* The semantics of C is that a truth value can be of any bitwidth,
           and the comparison should check if it is nonzero. Still, we would
           like to translate to the stricter Core Theory semantics such that
           the truth values are well-sorted. *)
        if not @@ is_boolean_exp cond then
          let tcond = Patch_c.Exp.typeof info.data cond in
          let scond = ty_of_base_type info tcond in
          let zero = Word.(
              to_bitvec @@ zero @@
              Option.value_exn (info.csize#bits tcond)) in
          let zero = CT.int scond zero in
          CT.neq (resort scond c) zero
        else resort T.Bool.t c in
      let* st = stmt_to_eff st ~info in
      let+ sf = stmt_to_eff sf ~info in
      CT.branch c st sf
    | GOTO label when String.(is_prefix ~prefix:"L_0x" label) ->
      let label = String.(chop_prefix_exn ~prefix:"L_" label) in
      !!(ctrl CT.(jmp (int info.word_sort Bitvec.(!$ label))))
    | GOTO label ->
      let* () =
        if Set.mem info.label_env label then !!()
        else fail @@ Format.sprintf "Undefined label %s" label in
      let+ label = T.Label.for_name label in
      ctrl CT.(goto label)

  let compile
      (hvars : Hvar.t list)
      (target : T.target)
      (patch : Cabs.definition) : T.Semantics.t KB.t =
    let* p = Patch_c.translate patch ~target in
    let* label_env = match Patch_c.label_env p with
      | Error err -> KB.fail err
      | Ok env -> !!env in
    let* info = make_interp_info hvars target p.data p.csize label_env in
    let* eff = stmt_to_eff p.body.stmt ~info in
    let+ sem = eff in
    sem

end
